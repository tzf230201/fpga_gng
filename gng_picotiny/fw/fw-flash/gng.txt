#include <stdint.h>

// =======================
//  UART hardware (sesuai contoh yang sudah jalan)
// =======================
typedef struct {
    volatile uint32_t DATA;
    volatile uint32_t CLKDIV;
} PICOUART;

#define UART0      ((PICOUART*)0x83000000)
#define CLK_FREQ   25175000u
#define UART_BAUD  115200u

// =======================
//  UART helper
// =======================
static void uart_init_hw(void)
{
    UART0->CLKDIV = CLK_FREQ / UART_BAUD - 2;
}

static void uart_putc(char c)
{
    if (c == '\n')
        UART0->DATA = '\r';
    UART0->DATA = (uint32_t)(uint8_t)c;
}

static void uart_puts(const char *s)
{
    while (*s) {
        uart_putc(*s++);
    }
}

static int32_t uart_getc_nonblock(void)
{
    // di core ini: DATA = -1 kalau tidak ada data
    return (int32_t)UART0->DATA;
}

static void uart_putu(unsigned int v)
{
    char buf[10];
    int pos = 0;

    if (v == 0) {
        uart_putc('0');
        return;
    }

    while (v > 0 && pos < (int)sizeof(buf)) {
        buf[pos++] = (char)('0' + (v % 10));
        v /= 10;
    }

    while (pos > 0) {
        uart_putc(buf[--pos]);
    }
}

static void uart_putf5(float f)
{
    if (f < 0.0f) {
        uart_putc('-');
        f = -f;
    }

    unsigned int ipart = (unsigned int)f;
    float frac = f - (float)ipart;
    unsigned int fpart = (unsigned int)(frac * 100000.0f + 0.5f); // 5 digit

    uart_putu(ipart);
    uart_putc('.');

    unsigned int div = 10000;
    while (div > 0) {
        unsigned int digit = (fpart / div) % 10;
        uart_putc((char)('0' + digit));
        div /= 10;
    }
}

// =======================
//  String & parsing helper
// =======================
static int starts_with(const char *s, const char *pfx)
{
    while (*pfx) {
        if (*s++ != *pfx++) return 0;
    }
    return 1;
}

static float parse_float(const char *p, const char **endp)
{
    int sign = 1;
    float val = 0.0f;

    if (*p == '-') {
        sign = -1;
        p++;
    }

    // integer part
    while (*p >= '0' && *p <= '9') {
        val = val * 10.0f + (float)(*p - '0');
        p++;
    }

    // fraction
    if (*p == '.') {
        p++;
        float factor = 0.1f;
        while (*p >= '0' && *p <= '9') {
            val += factor * (float)(*p - '0');
            factor *= 0.1f;
            p++;
        }
    }

    if (endp) *endp = p;
    return (float)sign * val;
}

// =======================
//  Buffer & dataset
// =======================
#define RXBUF_LEN    64
#define MAX_SAMPLES  512

static char rxbuf[RXBUF_LEN];
static uint32_t rxpos = 0;

static float xs[MAX_SAMPLES];
static float ys[MAX_SAMPLES];
static uint32_t nsamples = 0;
static uint32_t sample_count = 0;

// =======================
//  GNG data structure
// =======================

#define GNG_MAX_NODES     64
#define GNG_MAX_NEIGHBORS 6
#define GNG_MAX_AGE       50

#define GNG_LAMBDA        50      // tiap 50 iter tambah node
#define GNG_EPS_B         0.05f   // learning rate winner
#define GNG_EPS_N         0.006f  // learning rate neighbor (lebih kecil)
#define GNG_ALPHA         0.5f    // pengurangan error saat insert node
#define GNG_D_ERR         0.995f  // decay error global

static float gng_wx[GNG_MAX_NODES];
static float gng_wy[GNG_MAX_NODES];
static float gng_err[GNG_MAX_NODES];
static int8_t gng_nbr[GNG_MAX_NODES][GNG_MAX_NEIGHBORS];
static uint8_t gng_age[GNG_MAX_NODES][GNG_MAX_NEIGHBORS];
static uint32_t gng_nodes = 0;

// =======================
//  GNG helpers
// =======================
static float dist2(float x1, float y1, float x2, float y2)
{
    float dx = x1 - x2;
    float dy = y1 - y2;
    return dx*dx + dy*dy;
}

static void gng_init(void)
{
    uint32_t i, j;
    for (i = 0; i < GNG_MAX_NODES; i++) {
        gng_wx[i] = 0.0f;
        gng_wy[i] = 0.0f;
        gng_err[i] = 0.0f;
        for (j = 0; j < GNG_MAX_NEIGHBORS; j++) {
            gng_nbr[i][j] = -1;
            gng_age[i][j] = 0;
        }
    }

    if (nsamples < 2) {
        gng_nodes = 0;
        return;
    }

    gng_nodes = 2;
    gng_wx[0] = xs[0];
    gng_wy[0] = ys[0];
    gng_wx[1] = xs[nsamples - 1];
    gng_wy[1] = ys[nsamples - 1];
    gng_err[0] = 0.0f;
    gng_err[1] = 0.0f;
}

static int gng_find_neighbor_index(int a, int b)
{
    for (int k = 0; k < GNG_MAX_NEIGHBORS; k++) {
        if (gng_nbr[a][k] == b) return k;
    }
    return -1;
}

static void gng_add_directed_edge(int a, int b)
{
    if (a == b) return;

    int idx = gng_find_neighbor_index(a, b);
    if (idx >= 0) {
        gng_age[a][idx] = 0;
        return;
    }

    int free_idx = -1;
    uint8_t oldest_age = 0;
    int oldest_idx = 0;

    for (int k = 0; k < GNG_MAX_NEIGHBORS; k++) {
        if (gng_nbr[a][k] < 0) {
            free_idx = k;
            break;
        }
        if (gng_age[a][k] > oldest_age) {
            oldest_age = gng_age[a][k];
            oldest_idx = k;
        }
    }

    if (free_idx < 0)
        free_idx = oldest_idx;

    gng_nbr[a][free_idx] = (int8_t)b;
    gng_age[a][free_idx] = 0;
}

static void gng_add_edge(int a, int b)
{
    if (a == b) return;
    gng_add_directed_edge(a, b);
    gng_add_directed_edge(b, a);
}

static void gng_remove_edge_pair(int a, int b)
{
    int k = gng_find_neighbor_index(a, b);
    if (k >= 0) {
        gng_nbr[a][k] = -1;
        gng_age[a][k] = 0;
    }
    int k2 = gng_find_neighbor_index(b, a);
    if (k2 >= 0) {
        gng_nbr[b][k2] = -1;
        gng_age[b][k2] = 0;
    }
}

static void gng_increment_ages_from(int a)
{
    for (int k = 0; k < GNG_MAX_NEIGHBORS; k++) {
        int nb = gng_nbr[a][k];
        if (nb < 0) continue;

        if (gng_age[a][k] < 255)
            gng_age[a][k]++;

        int k2 = gng_find_neighbor_index(nb, a);
        if (k2 >= 0)
            gng_age[nb][k2] = gng_age[a][k];
    }
}

static void gng_remove_old_edges_from(int a)
{
    for (int k = 0; k < GNG_MAX_NEIGHBORS; k++) {
        int nb = gng_nbr[a][k];
        if (nb < 0) continue;

        if (gng_age[a][k] > GNG_MAX_AGE) {
            gng_remove_edge_pair(a, nb);
        }
    }
}

// =======================
//  GNG main algorithm
// =======================
static void run_gng_and_send(void)
{
    if (nsamples < 2) {
        uart_puts("GNG:\n");
        return;
    }

    gng_init();
    if (gng_nodes < 2) {
        uart_puts("GNG:\n");
        return;
    }

    // opsional: hubungkan node awal
    gng_add_edge(0, 1);

    int total_iter = (int)nsamples * 10;
    if (total_iter < (int)nsamples)
        total_iter = (int)nsamples;

    for (int t = 0; t < total_iter; t++) {
        float x = xs[t % nsamples];
        float y = ys[t % nsamples];

        // cari s1 & s2
        int s1 = -1, s2 = -1;
        float d1 = 1e30f, d2 = 1e30f;

        for (uint32_t i = 0; i < gng_nodes; i++) {
            float d = dist2(x, y, gng_wx[i], gng_wy[i]);
            if (d < d1) {
                d2 = d1;
                s2 = s1;
                d1 = d;
                s1 = (int)i;
            } else if (d < d2) {
                d2 = d;
                s2 = (int)i;
            }
        }

        if (s1 < 0 || s2 < 0)
            continue;

        // umurkan edges yang keluar dari s1
        gng_increment_ages_from(s1);

        // buat edge s1-s2 (dan reset umurnya)
        gng_add_edge(s1, s2);

        // update winner
        gng_wx[s1] += GNG_EPS_B * (x - gng_wx[s1]);
        gng_wy[s1] += GNG_EPS_B * (y - gng_wy[s1]);
        gng_err[s1] += d1;

        // update neighbors dari s1
        for (int k = 0; k < GNG_MAX_NEIGHBORS; k++) {
            int nb = gng_nbr[s1][k];
            if (nb < 0) continue;
            gng_wx[nb] += GNG_EPS_N * (x - gng_wx[nb]);
            gng_wy[nb] += GNG_EPS_N * (y - gng_wy[nb]);
        }

        // buang edge yang terlalu tua dari s1
        gng_remove_old_edges_from(s1);

        // tiap LAMBDA iter, tambahkan node baru
        if (((t + 1) % GNG_LAMBDA) == 0 && gng_nodes < GNG_MAX_NODES) {
            int q = 0;
            float max_err = gng_err[0];
            for (uint32_t i = 1; i < gng_nodes; i++) {
                if (gng_err[i] > max_err) {
                    max_err = gng_err[i];
                    q = (int)i;
                }
            }

            int f = -1;
            float max_err_n = -1.0f;
            for (int k = 0; k < GNG_MAX_NEIGHBORS; k++) {
                int nb = gng_nbr[q][k];
                if (nb < 0) continue;
                if (gng_err[nb] > max_err_n) {
                    max_err_n = gng_err[nb];
                    f = nb;
                }
            }

            if (f >= 0) {
                int r = (int)gng_nodes;
                gng_nodes++;

                gng_wx[r] = 0.5f * (gng_wx[q] + gng_wx[f]);
                gng_wy[r] = 0.5f * (gng_wy[q] + gng_wy[f]);
                gng_err[r] = gng_err[q];

                for (int k = 0; k < GNG_MAX_NEIGHBORS; k++) {
                    gng_nbr[r][k] = -1;
                    gng_age[r][k] = 0;
                }

                gng_err[q] *= GNG_ALPHA;
                gng_err[f] *= GNG_ALPHA;

                gng_remove_edge_pair(q, f);
                gng_add_edge(q, r);
                gng_add_edge(r, f);
            }
        }

        // decay error
        for (uint32_t i = 0; i < gng_nodes; i++) {
            gng_err[i] *= GNG_D_ERR;
        }
    }

    // kirim hasil ke Python
    uart_puts("GNG:");
    // nodes
    for (uint32_t i = 0; i < gng_nodes; i++) {
        uart_puts("N:");
        uart_putu(i);
        uart_putc(',');
        uart_putf5(gng_wx[i]);
        uart_putc(',');
        uart_putf5(gng_wy[i]);
        uart_putc(';');
    }
    // edges (i < j supaya tidak double)
    for (uint32_t i = 0; i < gng_nodes; i++) {
        for (int k = 0; k < GNG_MAX_NEIGHBORS; k++) {
            int nb = gng_nbr[i][k];
            if (nb < 0) continue;
            if (nb <= (int)i) continue;
            uart_puts("E:");
            uart_putu(i);
            uart_putc(',');
            uart_putu((unsigned int)nb);
            uart_putc(';');
        }
    }
    uart_putc('\n');
}

// =======================
//  Line handler
// =======================
static void handle_line(const char *line)
{
    if (starts_with(line, "DATA:")) {
        const char *p = line + 5;
        float x, y;

        x = parse_float(p, &p);
        if (*p == ',') p++;
        y = parse_float(p, &p);

        if (nsamples < MAX_SAMPLES) {
            xs[nsamples] = x;
            ys[nsamples] = y;
            nsamples++;
        }

        sample_count++;
        uart_puts("ACK ");
        uart_putu(sample_count);
        uart_putc('\n');
    }
    else if (starts_with(line, "DONE")) {
        run_gng_and_send();
        nsamples = 0;
        sample_count = 0;
    }
    else {
        uart_puts("UNKNOWN:");
        uart_puts(line);
        uart_putc('\n');
    }
}

// =======================
//  main loop
// =======================
void main(void)
{
    uart_init_hw();

    uart_puts("\nPicoRV GNG UART firmware with full GNG\n");
    uart_puts("Format: DATA:x,y; + \\n, lalu DONE;\\n\n");

    rxpos        = 0;
    nsamples     = 0;
    sample_count = 0;

    for (;;) {
        int32_t v = uart_getc_nonblock();
        if (v < 0) {
            continue;
        }

        char c = (char)v;

        if (c == '\r') {
            continue;
        } else if (c == '\n') {
            rxbuf[rxpos] = '\0';
            if (rxpos > 0) {
                handle_line(rxbuf);
            }
            rxpos = 0;
        } else {
            if (rxpos < (RXBUF_LEN - 1)) {
                rxbuf[rxpos++] = c;
            } else {
                rxpos = 0;
            }
        }
    }
}

// dibutuhkan oleh crt_flash.S
void irqCallback(void)
{
    // kosong
}
